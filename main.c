#include <stdio.h>
#include <math.h>
#include <limits.h>
#include "myparser.h"
#include "helper.h"

#define MAX_EDGES 100

// METHODS:
void findArbitrage(csvData csv);
void printArbitrage(const char **tickers, int *arbitrageOrder, int size);
void negateLogRates(double **vertices, int size);

int main()
{
    //TODO: make filepath a parameter
    csvData csv;
    csv = getCSVData();
    findArbitrage(csv);
    return 0;
}
void findArbitrage(csvData csv)
{
    int size = csv.size;

    int sourceIndex = 0;    // Could start with any source vertex
    double edges[size]; // Array of size n initialized with max double
    int predecessor[size];

    //Step 1: Negate and take log for every vertices;
    negateLogRates(csv.rates, size);

    // Step 2: Initialize distances from src to all other vertices as infinite
    for (int i = 0; i < size; i++) edges[i] = INT_MAX;
    edges[sourceIndex] = 0;

    // Step 3: Initialize pre with -1 for n records
    for (int i = 0; i < size; i++) predecessor[i] = -1;

    // Step 4: Relax Edges |vertices-1| times
    for (int i = 0; i <= (size - 1); i++)
    {
        for (int j = 0; j < size; j++) // current source vertex
        {
            for (int k = 0; k < size; k++) // current destination vertex
            {
                if (edges[k] > edges[j] + csv.rates[j][k])
                {
                    edges[k] = edges[j] + csv.rates[j][k];
                    predecessor[k] = j;
                }
            }
        }
    }

    // Step 5: If we can still Relax Edges then we have a negative cycle -> Exploitation possibility
    for (int i = 0; i < size; i++)
    {
        int currentI = i;
        for (int j = 0; j < size; j++)
        {
            // Checks if negative cycle exists, and use the predecessor array to print the arbitrage order
            if (edges[j] > edges[i] + csv.rates[i][j])
            {
                // Allocate arbitrage Order Array
                int arbitrageOrder[MAX_EDGES];
                for (int p = 0; p < MAX_EDGES; p++) arbitrageOrder[p] = -1;

                // Push i & j to arbitrage Order Array
                int counter = 0;
                arbitrageOrder[counter] = j; counter++;
                arbitrageOrder[counter] = i; counter++;

                // Iterating backwards starting from the source vertex till source vertex is encountered again
                // or vertex is already in arbitrage Order
                while ((isValueNotInArray(predecessor[i], arbitrageOrder)))
                {
                    arbitrageOrder[counter] = predecessor[i];
                    i = predecessor[i];
                    counter++;
                }

                // Add the last vertex
                arbitrageOrder[counter] = predecessor[i];
                counter++;
                printArbitrage(csv.columns, arbitrageOrder, counter);
            }
        }
        i = currentI;
    }
}

void negateLogRates(double **vertices, int size)
{
    int i, j;
    for (i = 0; i < size; i++)
    {
        for (j = 0; j < size; j++)
        {
            vertices[i][j] = -log(vertices[i][j]);
        }
    }
}

void printArbitrage(const char **tickers, int *arbitrageOrder, int size)
{
    int i;
    reverseArray(arbitrageOrder, size);

    printf("Arbitrage Opportunity detected: \n\n");
    for (i = 0; i < size; i++)
    {
        printf("%s", tickers[arbitrageOrder[i]]);
        if (size > i + 1) printf(" -> "); // Print arrow only n-1 times
    }
    printf("\n");
    printf("_______________________________\n\n\n");
}


